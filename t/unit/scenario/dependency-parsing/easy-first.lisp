(defpackage :hachee.t.scenario.dependency-parsing.easy-first
  (:use :cl :hachee.dependency-parsing.easy-first)
  (:export :train!-typical
           :parse-typical))
(in-package :hachee.t.scenario.dependency-parsing.easy-first)

(defun extract-features (configuration action)
  (declare (ignore configuration))
  (let ((type (action-type action))
        (arguments (hachee.dependency-parsing.easy-first::action-arguments
                    action)))
    (mapcar (lambda (list)
              (format nil "~{~A~^_~}" list))
            (list (list "v1" (car arguments))
                  (list "v2" (cadr arguments))
                  (list "type" type)
                  (list* "v1_v2" arguments)
                  (list* "type_v1" type (list (car arguments)))
                  (list* "type_v2" type (list (cadr arguments)))
                  (list* "type_v1_v2" type arguments)))))


(defmacro train!-typical (&key test)
  `(let ((scorer (make-scorer
                  :feature-string-extractor #'extract-features)))
     (let ((actions
            (train! (list 1 2 3 4 5 6 7 8 9)
                    (list (make-arc :source 2 :target 3)
                          (make-arc :source 1 :target 2)
                          (make-arc :source 5 :target 2)
                          (make-arc :source 7 :target 5)
                          (make-arc :source 6 :target 7)
                          (make-arc :source 4 :target 3)
                          (make-arc :source 8 :target 4)
                          (make-arc :source 9 :target 3))
                    :scorer scorer)))
       (let ((weights (scorer-weights scorer)))
         (,test (equal (hash-table-count weights) 69))
         (,test (equal (sort (alexandria:hash-table-alist weights) #'string<
                             :key #'car)
                       '(("type_ATTACH" . 1) ("type_MOVE" . -1)
                         ("type_v1_ATTACH_1" . 1) ("type_v1_ATTACH_2" . 1)
                         ("type_v1_ATTACH_3" . -2) ("type_v1_ATTACH_4" . -1)
                         ("type_v1_ATTACH_5" . 1) ("type_v1_ATTACH_6" . 1)
                         ("type_v1_ATTACH_7" . 1) ("type_v1_ATTACH_8" . 0)
                         ("type_v1_ATTACH_9" . -1) ("type_v1_MOVE_2" . -1)
                         ("type_v1_MOVE_4" . 0) ("type_v1_v2_ATTACH_1_2" . 1)
                         ("type_v1_v2_ATTACH_2_3" . 1)
                         ("type_v1_v2_ATTACH_3_2" . -1)
                         ("type_v1_v2_ATTACH_3_9" . -1)
                         ("type_v1_v2_ATTACH_4_5" . -1)
                         ("type_v1_v2_ATTACH_5_2" . 1)
                         ("type_v1_v2_ATTACH_6_7" . 1)
                         ("type_v1_v2_ATTACH_7_5" . 1)
                         ("type_v1_v2_ATTACH_8_4" . 1)
                         ("type_v1_v2_ATTACH_8_7" . -1)
                         ("type_v1_v2_ATTACH_9_3" . 1)
                         ("type_v1_v2_ATTACH_9_4" . -1)
                         ("type_v1_v2_ATTACH_9_8" . -1)
                         ("type_v1_v2_MOVE_2_3" . -1)
                         ("type_v1_v2_MOVE_4_5" . 1)
                         ("type_v1_v2_MOVE_4_8" . -1)
                         ("type_v2_ATTACH_2" . 1) ("type_v2_ATTACH_3" . 2)
                         ("type_v2_ATTACH_4" . 0) ("type_v2_ATTACH_5" . 0)
                         ("type_v2_ATTACH_7" . 0) ("type_v2_ATTACH_8" . -1)
                         ("type_v2_ATTACH_9" . -1) ("type_v2_MOVE_3" . -1)
                         ("type_v2_MOVE_5" . 1) ("type_v2_MOVE_8" . -1)
                         ("v1_1" . 1) ("v1_2" . 0)  ("v1_3" . -2)
                         ("v1_4" . -1) ("v1_5" . 1) ("v1_6" . 1) ("v1_7" . 1)
                         ("v1_8" . 0) ("v1_9" . -1) ("v1_v2_1_2" . 1)
                         ("v1_v2_2_3" . 0) ("v1_v2_3_2" . -1)
                         ("v1_v2_3_9" . -1) ("v1_v2_4_5" . 0)
                         ("v1_v2_4_8" . -1) ("v1_v2_5_2" . 1)
                         ("v1_v2_6_7" . 1) ("v1_v2_7_5" . 1)
                         ("v1_v2_8_4" . 1) ("v1_v2_8_7" . -1)
                         ("v1_v2_9_3" . 1) ("v1_v2_9_4" . -1)
                         ("v1_v2_9_8" . -1)
                         ("v2_2" . 1) ("v2_3" . 1) ("v2_4" . 0) ("v2_5" . 1)
                         ("v2_7" . 0) ("v2_8" . -2) ("v2_9" . -1)))))
       (,test
        (equal (mapcar #'action-type actions)
               (list :nop :attach :nop :attach :nop :attach :nop :move
                     :move :move :nop :attach :nop :attach :nop :attach
                     :attach :nop :attach :attach))))))

(defmacro parse-typical (&key test)
  `(let ((scorer
          (make-scorer :feature-string-extractor #'extract-features))
         (vertices
          (list 1 2 3 4 5 6 7 8 9))
         (gold-arc-list
          (list (make-arc :source 2 :target 3)
                (make-arc :source 1 :target 2)
                (make-arc :source 5 :target 2)
                (make-arc :source 7 :target 5)
                (make-arc :source 6 :target 7)
                (make-arc :source 4 :target 3)
                (make-arc :source 8 :target 4)
                (make-arc :source 9 :target 3))))
     ;; 4回実行すれば十分オーバーフィットする
     (loop repeat 4 do (train! vertices gold-arc-list :scorer scorer))
     (let ((arcs (parse vertices :scorer scorer)))
       (,test (= (length arcs) (length gold-arc-list)))
       (,test (null
               (set-difference arcs gold-arc-list
                :test (lambda (a1 a2)
                        (and (= (arc-source a1)
                                (arc-source a2))
                             (= (arc-target a1)
                                (arc-target a2))))))))))
